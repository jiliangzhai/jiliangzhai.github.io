<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[生锈的车轮]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://rustblogs.com/"/>
  <updated>2016-01-14T15:03:02.000Z</updated>
  <id>http://rustblogs.com/</id>
  
  <author>
    <name><![CDATA[rust_33]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[CALayer and Core Animation]]></title>
    <link href="http://rustblogs.com/2016/01/13/CALayer-and-Core-Animation/"/>
    <id>http://rustblogs.com/2016/01/13/CALayer-and-Core-Animation/</id>
    <published>2016-01-13T13:22:22.000Z</published>
    <updated>2016-01-14T15:03:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="CAlayer_and_Core_Animation"><a href="#CAlayer_and_Core_Animation" class="headerlink" title="CAlayer and Core Animation"></a>CAlayer and Core Animation</h2><h3 id="CALayer_u7ED8_u5236"><a href="#CALayer_u7ED8_u5236" class="headerlink" title="CALayer绘制"></a>CALayer绘制</h3><p>CALayer的绘制主要设计两个方法<code>drawLayer: InContext:</code>和<code>drawInContext:</code>两个方法都提供了一个Context所以绘制方法类似于上一篇讲到的Quartz 2D的绘制方法，可以绘制基本图形，图片以及文字。另CALyer的很多属性都包含隐式动画效果，属性的改变会引发动画效果。</p>
<p>下面这段代码演示的就是CALyer中的基本绘制方法遗迹隐式动画的效果。</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor whiteColor];

    shadowLayer= [[CALayer alloc]init];
    shadowLayer.bounds = CGRectMake(0, 0, 200, 200);;
    shadowLayer.position = CGPointMake(self.view.frame.size.width/2, 200);
    //设置好圆角，成为圆形
    shadowLayer.cornerRadius = 100;
    //阴影颜色
    shadowLayer.shadowColor = [UIColor grayColor].CGColor;
    shadowLayer.shadowOffset = CGSizeMake(2, 1);
    //透明度
    shadowLayer.shadowOpacity=1;
    shadowLayer.borderColor = [UIColor whiteColor].CGColor;
    shadowLayer.borderWidth = 2.0;
    [self.view.layer addSublayer:shadowLayer];

    layer = [[CALayer alloc] init];
    layer.bounds = CGRectMake(0, 0, 200, 200);
    layer.position = CGPointMake(self.view.frame.size.width/2, 200);
    layer.backgroundColor = [UIColor purpleColor].CGColor;
    layer.cornerRadius = 100;
    layer.masksToBounds = YES;
    layer.borderColor = [UIColor whiteColor].CGColor;
    layer.borderWidth = 2.0;
    //代理
    layer.delegate = self;
    //调用setNeedDisplay才能调用代理方法
    [layer setNeedsDisplay];
    [self.view.layer addSublayer:layer];
    targetRect = layer.frame;//calayer有一个name属性可以用以区分layer
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    UITouch *touch = [touches anyObject];
    CGPoint location = [touch locationInView:self.view];

    if (CGRectContainsPoint(targetRect, location)) {
    //创建一个，点击图层，图层缩小的动画，这里就是隐式动画
        [layer setValue:@0.6 forKeyPath:@&quot;transform.scale&quot;];
        [shadowLayer setValue:@0.6 forKeyPath:@&quot;transform.scale&quot;];
    }
}

- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    UITouch *touch = [touches anyObject];
    CGPoint location = [touch locationInView:self.view];

    if (CGRectContainsPoint(targetRect, location)) {
    //点击结束后图层恢复大小，当然也有一个动画效果
        [layer setValue:@1.0 forKeyPath:@&quot;transform.scale&quot;];
        [shadowLayer setValue:@1.0 forKeyPath:@&quot;transform.scale&quot;];
    }

}
//代理方法，在方法中进行绘制
- (void)drawLayer:(CALayer *)myLayer inContext:(CGContextRef)ctx
{
    UIImage *image = [self thumbnailMakerWithImage:[UIImage imageNamed:@&quot;panda.jpg&quot;]];
    //储存图层状态
    CGContextSaveGState(ctx);
    //图层形变，CALayer的transform是3D的所以只要绕y周旋转180度就可以是左上角坐标系了。
    myLayer.transform = CATransform3DMakeRotation(M_PI, 1, 0, 0);
    //绘制一张图片到图层,这里无法使用UKit封装过的方法
    CGContextDrawImage(ctx, CGRectMake(CGRectGetWidth(myLayer.bounds)/2-image.size.width/2, CGRectGetHeight(myLayer.bounds)/2-image.size.height/2, image.size.width, image.size.height), image.CGImage);
    //恢复图层状态
    CGContextRestoreGState(ctx);
}
//这个方法，是制作缩略图的方法
- (UIImage *)thumbnailMakerWithImage:(UIImage *)image
{
    if (!image) {
        return nil;
    }

    CGSize imageSize = image.size;
    float ratioX = 200/imageSize.width;
    float ratioY = 200/imageSize.height;
    float ratio = MAX(ratioX, ratioY);

    float targetWidth = ratio*imageSize.width;
    float targetHeight = ratio*imageSize.height;

    float originX = (200-targetWidth)/2.0;
    float originY = (200-targetHeight)/2.0;

    UIGraphicsBeginImageContext(CGSizeMake(200, 200));
    [image drawInRect:CGRectMake(originX, originY, targetWidth, targetHeight)];
    UIImage *thumbnail = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();

    return thumbnail;
}
</code></pre><p>可以看一下具体效果：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/calayer.gif" alt="calyer"></p>
<p>有几个点需注意：</p>
<ol>
<li>UIView的根图层没有隐式动画的效果</li>
<li>以上代码时利用<code>drawLayer: InContext:</code>代理方法进行的绘制，我们也可以自定义图层的<code>drawInContext进行绘制</code>绘制的方法是相同的。</li>
<li>需要调用<code>setNeedDisplay</code>才能调用以上两种方法进行绘制。</li>
<li>CALalayer的<code>transform</code>属性是<code>CATransform3D</code>，包含x轴以及y轴的旋转，所以调整图层坐标系变得很简单，只需绕y轴180度就可以了，需要明确的是图层的形变是按照锚点属性进行的。</li>
<li>图层的隐式动画我们无法很好的进行控制，所以有时候需要利用Core Animation或者UIView封装的动画。</li>
<li><code>maskToBounds</code>和阴影效果无法同时存在，所以在上面的代码中专门创建了一个阴影图层。来承载阴影效果。</li>
<li>CALayer有一个<code>name</code>属性可以让我们对图层进行区分。</li>
<li>CALayer的<code>frame</code>属性不具有隐式动画效果，中心点是<code>position</code>不是<code>center</code>。</li>
</ol>
<h3 id="Core_Animation"><a href="#Core_Animation" class="headerlink" title="Core Animation"></a>Core Animation</h3><p>上面也说到了，隐式动画我们无法进行控制，所以有时候要使用Core Animation。动画基本分为以下几类：基本动画、关键帧动画、动画组、转场动画。下面我们逐一说明。</p>
<h4 id="u57FA_u672C_u52A8_u753B"><a href="#u57FA_u672C_u52A8_u753B" class="headerlink" title="基本动画"></a>基本动画</h4><p>基本动画属于属性动画范畴，通过属性的修改引发动画效果，我们可以设定初始值以及终值，中间值由系统进行插值从而形成一段连续的动画效果。</p>
<p>下面以代码来说明添加基本动画的过程，大致包括三个步骤：创建基本动画、动画属性设置、添加基本动画至图层。</p>
<pre><code> //创建基本动画
CABasicAnimation *rotate = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];
//动画时间
rotate.duration = 1.0;
//初始值，也可以不设置，那么默认为该属性的当前值为初始值
rotate.fromValue = @0;
//终值
rotate.toValue = @(2*M_PI);
//重复次数
rotate.repeatCount = 0;
//是否在动画完成后移除动画
rotate.removedOnCompletion = NO;
//添加动画至图层，根据key值可以对动画进行区分。
[bubbleLayer addAnimation:rotate forKey:@&quot;rotation&quot;];
</code></pre><p>上面是一段旋转动画的创建过程，也是基本动画创建的一般过程。需要注意的是，动画效果并不会在动画结束后将该属性值更改为<code>toValue</code>，而是恢复到动画开始前的的当前值。如果需要改变该属性值，需要我们手动去更改。更改方法下面会说到。</p>
<h4 id="u5173_u952E_u5E27_u52A8_u753B"><a href="#u5173_u952E_u5E27_u52A8_u753B" class="headerlink" title="关键帧动画"></a>关键帧动画</h4><p>关键帧动画也属于属性动画，与基本动画不同的是我们可以进行更多的点的控制，而不是只有初始值和终值。创建过程与基本动画类似，下面代码演示这一过程。</p>
<pre><code>//创建关键帧动画
CAKeyframeAnimation* keyframeAnimation=[CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];

NSValue* value1=[NSValue valueWithCGPoint:layer.position];
NSValue* value2=[NSValue valueWithCGPoint:CGPointMake(80, 220)];
NSValue* value3=[NSValue valueWithCGPoint:CGPointMake(45, 300)];
NSValue* value4=[NSValue valueWithCGPoint:CGPointMake(55, 400)];
NSArray* values=@[value1,value2,value3,value4];
//设置每帧的初始值也就是前一帧的终值
keyframeAnimation.values=values;
keyframeAnimation.duration=8.0;
//设置开始时间，cacurrentmediatime()是现在的时间，可以实现延时效果
keyframeAnimation.beginTime=CACurrentMediaTime()+2;
//keyTimes可以控制每一帧的时间，用0-1的值进行表示。
keyframeAnimation.keyTimes = @[@0.0,@0.25,@0.75,@1.0];
//动画计算模式
keyframeAnimation.calculationMode = kCAAnimationCubic;
//添加动画至图层
[layer addAnimation:keyframeAnimation forKey:@&quot;keyframeAnimation1&quot;];
</code></pre><p>对于关键帧动画我们还可以通过绘制路径进行动画控制，代码如下；</p>
<pre><code>CAKeyframeAnimation* keyframeAnimation=[CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];

CGMutablePathRef path=CGPathCreateMutable();
CGPathMoveToPoint(path, nil, layer.position.x, layer.position.y);
CGPathAddCurveToPoint(path, nil, 160, 280, -30, 300, 55, 400);

keyframeAnimation.path=path;
keyframeAnimation.duration=8.0;
keyframeAnimation.beginTime=CACurrentMediaTime()+2;

[layer addAnimation:keyframeAnimation forKey:@&quot;keyframeAnimation2&quot;];
</code></pre><p> 上面的代码中的路径是贝塞尔曲线，当然我么也可以绘制其他曲线。</p>
<h4 id="u52A8_u753B_u7EC4"><a href="#u52A8_u753B_u7EC4" class="headerlink" title="动画组"></a>动画组</h4><p>动画效果通常是多种运动的叠加效果，上面说到的基本动画和关键帧动画每次只能对一个属性进行动画控制，我们可以用动画组来解决这个问题。动画组中的动画都受控于动画组，而且放到动画组中的动画可以并发执行，以此可以实现更加复杂的动画效果。</p>
<p>动画组的使用分以下几步：创建动画组、创建几个基本动画或关键帧动画、将动画添加至动画组、设置动画组属性、将动画组添加至图层。</p>
<p>下面用一段代码来演示创建过程。</p>
<pre><code>- (CAKeyframeAnimation*) transitionAnimation
{
    CAKeyframeAnimation* keyframeAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];

    CGMutablePathRef path = CGPathCreateMutable();
    CGPathMoveToPoint(path, nil, layer.position.x, layer.position.y);
    CGPathAddCurveToPoint(path, nil, 160, 280, -30, 300, 55, 400);

    keyframeAnimation.path = path;

    return keyframeAnimation;
}

-(CABasicAnimation*) rotationAnimation
{
    CABasicAnimation* rotateAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];

    rotateAnimation.toValue = [NSNumber numberWithFloat:M_PI*2];
    rotateAnimation.repeatCount = HUGE_VAL;
    rotateAnimation.removedOnCompletion = NO;

    return rotateAnimation;
}

- (void)animationGroup
{
    CAAnimationGroup* group = [CAAnimationGroup animation];
    CABasicAnimation* basicAnimation = [self rotationAnimation];
    CAKeyframeAnimation* keyframeAnimation=[self transitionAnimation];

    group.animations = @[basicAnimation,keyframeAnimation];
    group.duration = 8.0;
    group.delegate = self;
    group.beginTime = CACurrentMediaTime()+3;

    [layer addAnimation:group forKey:@&quot;gropuAnimation&quot;];

}
</code></pre><p>上面的动画组是平移和旋转的复合效果，下面说一下利用代理方法在动画结束后更改属性值为动画终值的方法，因为有隐式动画的存在，还涉及到关闭隐式动画的问题。方法见下面的代码：</p>
<pre><code>- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
{
    // 1[CATransaction begin];
    // 2[CATransaction setDisableActions:YES];
    //设置属性值
    layer.position=CGPointMake(55, 400);

    // 3[CATransaction commit];
}
</code></pre><p>动画结束后会调用<code>animationDidStop: finished:</code>方法，在该方法中我们进行属性值的修改，注释的1、2、3是关闭隐私动画的代码。</p>
<p>效果图如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/group.gif" alt="group"></p>
<h4 id="u8F6C_u573A_u52A8_u753B"><a href="#u8F6C_u573A_u52A8_u753B" class="headerlink" title="转场动画"></a>转场动画</h4><p>转场动画时视图切换时的动画效果，比如翻页效果，立方体效果等。这里介绍的是提供的一些方法，下面的代码会展示一个转场动画的创建过程。</p>
<pre><code>//初始化转场动画
CATransition *transition = [[CATransition alloc] init];
//transition.type=@&quot;cube&quot;;//立方体效果
//transition.type=@&quot;oglFlip&quot;;//翻转效果
//transition.type=@&quot;suckEffect&quot;;//抽纸效果
//效果类型
transition.type=@&quot;rippleEffect&quot;;//波纹效果
//transition.type=@&quot;cameraIrisHollowOpen&quot;;//摄像头打开效果
//以上是私有api，公开api有fade movein push reveal

if (next) {
    //确定转场方向
    transition.subtype = kCATransitionFromRight;
}else
    transition.subtype = kCATransitionFromLeft;
//设置动画时间
transition.duration = 1.0;
//设定下一视图
imageView.image = [self nextImage:next];
//将动画加入图层
[imageView.layer addAnimation:transition forKey:@&quot;transition&quot;];
</code></pre><p>创建的过程注释中很清晰，系统提供了很多方法，上面的代码中更改<code>type</code>属性就可以实现不同的效果。上面的代码中是波纹效果。效果图如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/zhuanchang.gif" alt="zhuanchang"></p>
<h4 id="u52A8_u753B_u7684_u6682_u505C_u4E0E_u6062_u590D_u64CD_u4F5C"><a href="#u52A8_u753B_u7684_u6682_u505C_u4E0E_u6062_u590D_u64CD_u4F5C" class="headerlink" title="动画的暂停与恢复操作"></a>动画的暂停与恢复操作</h4><p> CAAniattion和CALayer都有一个<code>speed</code> 属性，可以对动画的速度进行控制，当速度为0 时就可以有暂停的效果，问题的关键在于2个点，当<code>speed</code>设置为0时，出现的状态应该为暂停前的状态，恢复时能够承接暂停前状态运行下去，解决这个问题要结合<code>offset</code>和<code>beginTime</code>两个属性，关于动画中的时间的诸多概念推荐一篇文章<a href="">控制动画时间</a>。下面给出暂停和恢复的代码：</p>
<pre><code>-(void) animationResume
{
    //计算动画开始时间，确保恢复状态
    CFTimeInterval begintime= CACurrentMediaTime()-layer.timeOffset;
    layer.timeOffset=0;
    layer.beginTime=begintime;
    //恢复速度
    layer.speed=1;

}

-(void) animationPause
{    //获取图层动画的媒体时间
    CFTimeInterval interval=[layer convertTime:CACurrentMediaTime() fromLayer:nil];
    //设置时间偏移量，确保暂停状态
    [layer setTimeOffset:interval];
    //速度为0
    layer.speed=0;
}
</code></pre><p>上面代码中图层中的所有动画将同时暂停和恢复。效果如下图：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/zanting.gif" alt="zanting"></p>
<h3 id="UIView_u5C01_u88C5_u52A8_u753B"><a href="#UIView_u5C01_u88C5_u52A8_u753B" class="headerlink" title="UIView封装动画"></a>UIView封装动画</h3><p>UIView对于基本动画关键帧动画和转场动画都有封装，使用方法也比core animation也要简单。下面我们用UIView封装动画来实现上面用core animation实现的基础动画、关键帧动画、转场动画效果。</p>
<h4 id="u57FA_u7840_u52A8_u753B"><a href="#u57FA_u7840_u52A8_u753B" class="headerlink" title="基础动画"></a>基础动画</h4><p>基础动画的实现方法有两种一种是block方法，另一种是静态方法。下面给出了这两种方法的代码实现。</p>
<pre><code> [UIView animateWithDuration:3.0 delay:2.0 options:UIViewAnimationOptionCurveEaseInOut animations:^{
    bubbleImageView.layer.transform = CATransform3DMakeRotation(M_PI, 0, 0, 1);
} completion:^(BOOL finished) {
    if (finished) {
        NSLog(@&quot;finished&quot;);
    }
}];
</code></pre><p>block方法</p>
<pre><code>  [UIView beginAnimations:@&quot;bubble&quot; context:nil];
[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];
[UIView setAnimationDuration:2.0];
bubbleImageView.layer.transform = CATransform3DMakeRotation(M_PI, 0, 0, 1);
[UIView commitAnimations];
</code></pre><p>静态方法</p>
<h4 id="u5173_u952E_u5E27_u52A8_u753B-1"><a href="#u5173_u952E_u5E27_u52A8_u753B-1" class="headerlink" title="关键帧动画"></a>关键帧动画</h4><pre><code>[UIView animateKeyframesWithDuration:10.0 delay:0 options:UIViewAnimationOptionRepeat|UIViewKeyframeAnimationOptionCalculationModeLinear animations:^{
    UIView addKeyframeWithRelativeStartTime:0 relativeDuration:0.5 animations:^{
    CATransform3D transform = CATransform3DIdentity;
    CATransform3DScale(rotation, 0.5, 0.5, 0.5);
        imageView.layer.transform = scale;
    }];

    [UIView addKeyframeWithRelativeStartTime:0.5 relativeDuration:0.5 animations:^{
        CATransform3D transform = CATransform3DIdentity;
        CATransform3D rotation = CATransform3DRotate(transform, 2*M_PI, 0, 0, 1);
        CATransform3D scale = CATransform3DScale(rotation, 1.0,1.0,1.0);
        imageView.layer.transform = scale;
    }];

} completion:^(BOOL finished) {
    NSLog(@&quot;finished&quot;);
}];
</code></pre><p>实现的方法很简单就不多赘述了。</p>
<h4 id="u8F6C_u573A_u52A8_u753B-1"><a href="#u8F6C_u573A_u52A8_u753B-1" class="headerlink" title="转场动画"></a>转场动画</h4><pre><code>UIViewAnimationOptions options;
if (next) {
    options = UIViewAnimationOptionCurveLinear|UIViewAnimationOptionTransitionFlipFromRight;
}else
    options = UIViewAnimationOptionCurveLinear|UIViewAnimationOptionTransitionFlipFromLeft;

[UIView transitionWithView:imageView duration:1.0 options:options animations:^{
    imageView.image=[self nextImage:next];
} completion:nil];
</code></pre><p> 有了core animation的知识基础后，利用UIView封装动画变的非常简单。</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>这篇博了主要讲了CALayer的绘制、core animation动画实现以及UIView封装动画的实现，其中利用封装的方法更为简单，core animation可以对动画进行更细致的控制以实现更复杂的效果，按需使用吧。</p>
<p>有兴趣的同学可以下载<a href="https://github.com/jiliangzhai/RUSTCALayerandCoreAnimation" target="_blank" rel="external">DEMO</a>看一下。<br>作为新手写的东西可能不尽深入与详尽，内容主要的重心还是放在了功能的实现上，相关内容图鉴一篇博客：<a href="http://www.cnblogs.com/kenshincui/p/3972100.html#uiviewanimation" target="_blank" rel="external">iOS开发系列–让你的应用“动”起来</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[这篇博客的内容主要是三个部分：CALayer的绘制、Core Animation、UIView封装的动画。利用演示代码展示绘制及动画效果的实现。]]>
    
    </summary>
    
      <category term="CALayer CoreAnimation" scheme="http://rustblogs.com/tags/CALayer-CoreAnimation/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Quartz 2D图形绘制基础]]></title>
    <link href="http://rustblogs.com/2016/01/06/quartz2D/"/>
    <id>http://rustblogs.com/2016/01/06/quartz2D/</id>
    <published>2016-01-06T12:30:33.000Z</published>
    <updated>2016-01-07T12:43:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Quartz_2D_u56FE_u5F62_u7ED8_u5236_u57FA_u7840"><a href="#Quartz_2D_u56FE_u5F62_u7ED8_u5236_u57FA_u7840" class="headerlink" title="Quartz 2D图形绘制基础"></a>Quartz 2D图形绘制基础</h2><p>Quartz 2D是Core Graphic框架的一部分，可以用以进行2D图形的绘制。在这篇博客中以几个功能的实现介绍一下Quartz 2D的基础知识。<br>在这篇博客中我们将涉及到的功能包括：</p>
<ol>
<li>基础图形的绘制</li>
<li>渐变填充</li>
<li>图形上下文的形变</li>
<li>填充模式</li>
<li>位图绘制</li>
<li>PDF绘制</li>
</ol>
<h3 id="u57FA_u7840_u56FE_u5F62_u7ED8_u5236"><a href="#u57FA_u7840_u56FE_u5F62_u7ED8_u5236" class="headerlink" title="基础图形绘制"></a>基础图形绘制</h3><p>首先要介绍最简单的基础图形绘制，包括直线、曲线、矩形、圆形等。利用基础图形的绘制我们可以对绘图流程有所了解。<br>绘制过程大致可分为以下几个步骤：</p>
<ol>
<li>获取图形上下文</li>
<li>构建路径</li>
<li>加入路径至图形上下文</li>
<li>设置图形上下文想干参数，包括颜色、线条、阴影等。</li>
<li>进行绘制</li>
</ol>
<p>在UI控件的<code>drawRect</code>方法中我们可以通过<code>UIGraphicsGetCurrentContext()</code>方法获得当前的图形上下文，然后在该图形上下文中进行绘制。下面以最简单的线条绘制进行说明。</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得图形上下文
    CGContextRef context = UIGraphicsGetCurrentContext();
    //创建路径
    CGMutablePathRef path = CGPathCreateMutable();
    //线段的起始点
    CGPathMoveToPoint(path, nil, 10, 124);
    //线段终点
    CGPathAddLineToPoint(path, nil, self.bounds.size.width-10,124);
    //添加第二条线
    CGPathAddLineToPoint(path, nil, self.bounds.size.width/2, 164);
    //添加第三条线
    CGPathAddLineToPoint(path, nil, 10, 124);
    //将路径添加到上下文
    CGContextAddPath(context, path);
    //设置线的端点形状
    CGContextSetLineCap(context, kCGLineCapButt);
    //设置交点形状
    CGContextSetLineJoin(context, kCGLineJoinRound);
    //设置线条宽度
    CGContextSetLineWidth(context, 3.0);
    //设置线条颜色，在这里需要将UIColorz转化为CGColor
    CGContextSetStrokeColorWithColor(context, [UIColor redColor].CGColor);
    //进行绘制，第二个参数可以选择填充、绘制边框或两者都绘制
    CGContextDrawPath(context, kCGPathStroke);
    //由于Quartz 2D 属于Core Graphics框架所以对创建的对象要自己给释放掉。带有creat copy字样创建的对象都需要我们自己释放。
    CGPathRelease(path);
}
</code></pre><p>以上就是绘制图形的基本过程，需要注意的是对象的释放部分不要忘记。</p>
<h3 id="u6E10_u53D8_u8272_u586B_u5145"><a href="#u6E10_u53D8_u8272_u586B_u5145" class="headerlink" title="渐变色填充"></a>渐变色填充</h3><p>渐变色的视线需要我们在填充区域的不同位置（以0-1的某个数值表示）进行颜色的设置，设置的颜色之间的区域系统会进行补充。大致过程如下：</p>
<ol>
<li>确定使用的颜色空间，比如RGB、CMYK或者Gray。</li>
<li>确定填充区域某些位置的颜色。</li>
<li>构建<code>CGContextGradientRef</code>。</li>
<li>进行填充，按照填充的方向不同，有两种调用方式线性渐变和径向渐变。</li>
</ol>
<p>以RGB为例，一个颜色由4个数值决定{red,green,blue,alpha}。下面的代码演示了使用RGB颜色空间进行线性渐变和径向渐变。</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    CGContextRef context = UIGraphicsGetCurrentContext();

    {
        //储存当先图形上下文状态
        CGContextSaveGState(context);
        //裁减图形上下文
        CGContextClipToRect(context, CGRectMake((rect.size.width-200)/2, 84, 200, 200));
        //构建颜色空间，这里选择RGB
        CGColorSpaceRef colorSpace =     CGColorSpaceCreateDeviceRGB();
        //创建3个颜色
        CGFloat component[12] = {191.0/255.0,21.0/255.0,133.0/255.0,1,218.0/255.0,112.0/255.0,214.0/255.0,1.0,216.0/255.0,191.0/255.0,216.0/255.0,1.0};
        //3个颜色对应的填充区域的位置
        CGFloat locations[3] = {0,0.3,1.0};
        //创建CGGradientRef，三个参数分别为颜色空间、颜色、数量
        CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, component, locations, 3);
        //确定起始点和终点，选择进行线性渐变
        //kCGGradientDrawsAfterEndLocation表征开始位置之前不进行填充，结束位置后继续填充
        //kCGGradientDrawsBeforeStartLocation表征开始位置之前进行填充，结束位置后不进行填充
        CGContextDrawLinearGradient(context, gradient, CGPointMake(0,0), CGPointMake(200,200), kCGGradientDrawsAfterEndLocation);
        //恢复图形上下文状态
        CGContextRestoreGState(context);
        //对象释放
        CGColorSpaceRelease(colorSpace);
        CGGradientRelease(gradient);
    }

    {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGFloat component[12] = {191.0/255.0,21.0/255.0,133.0/255.0,1,218.0/255.0,112.0/255.0,214.0/255.0,1.0,216.0/255.0,191.0/255.0,216.0/255.0,1.0};
        CGFloat locations[3] = {0,0.3,1.0};
        CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, component, locations, 3);
        //确定起始起始半径，结束位置结束半径，选择进行径向填充。
        CGContextDrawRadialGradient(context, gradient, CGPointMake(rect.size.width/2,404 ), 0, CGPointMake(rect.size.width/2, 404), 100, kCGGradientDrawsBeforeStartLocation);

        CGColorSpaceRelease(colorSpace);
        CGGradientRelease(gradient);
    }

}
</code></pre><p>上面代码中的<code>CGContextSaveGState(context)``CGContextRestoreGState(context)</code>分别是储存和恢复图形上下文状态，由于在线性渐变中我对上下文进行了裁剪<code>CGContextClipToRect()</code>，而在径向渐变中不想上下文中只有被裁剪过的区域所以在裁剪前存储了图形上下文，在使用后又恢复来它。效果图如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/jianbian1.png" alt="image"></p>
<h3 id="u56FE_u5F62_u4E0A_u4E0B_u6587_u5F62_u53D8"><a href="#u56FE_u5F62_u4E0A_u4E0B_u6587_u5F62_u53D8" class="headerlink" title="图形上下文形变"></a>图形上下文形变</h3><p>图形上下文的形变包括，平移、放缩以及绕z轴的旋转，Quartz 2D的坐标原点在左下角，单UIKit对其进行了变换，统一在了屏幕左上角，所以下面的变换是基于左上角的原点的，这一点需要注意。另外在做图形上下文变换前最好进行图形上下文状态的储存，使用完后恢复状态，以便再次使用。下面以一个图像的绘制对图形上下文的变换进行说明，代码如下：</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    CGContextRef context = UIGraphicsGetCurrentContext();

    CGContextSaveGState(context);
//平移
    CGContextTranslateCTM(context,90, 50);
//缩小
    CGContextScaleCTM(context, 0.8,0.8);
//旋转
    CGContextRotateCTM(context, M_PI_4/4);

    UIImage *image = [UIImage imageNamed:@&quot;boy.jpg&quot;];
//在上下文中绘制图像
    [image drawInRect:CGRectMake(0, 74, 240, 180)];

    CGContextRestoreGState(context);
}    
</code></pre><p>效果图如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/xingbian1.png" alt="image"></p>
<h3 id="u586B_u5145_u6A21_u5F0F"><a href="#u586B_u5145_u6A21_u5F0F" class="headerlink" title="填充模式"></a>填充模式</h3><p>我们可以自定义一种样式进行填充，类似于贴瓷砖，我们定义的样式就是瓷砖的样式。然后以全都一样的瓷砖去铺满要填充的区域。</p>
<p>Quartz 2D支持两种填充模式，有颜色填充和无颜色填充。这里使用有颜色填充进行功能的演示。过程如下：</p>
<ol>
<li>创建一个填充的颜色空间</li>
<li>构建自定义样式，即瓷砖的样式，创建时需要构建一个一个callback方法，在该方法中绘制自定义样式。</li>
<li>使用CGPatternCreate方法创建一个填充模式</li>
<li>设定图形上下文的填充模式</li>
<li>绘制图形</li>
</ol>
<p>下面通过代码及效果图对填充模式进行说明。</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    CGContextRef context = UIGraphicsGetCurrentContext();
    //创建填充的颜色空间
    CGColorSpaceRef colorSpace = CGColorSpaceCreatePattern(NULL);
    CGContextSetFillColorSpace(context, colorSpace);
    //callback方法
    CGPatternCallbacks callBack = {0,&amp;drawTile,NULL};
    //根据callback方法创建自定义样式，参数如下
    info:传递给callback的参数
    bounds:自定义样式也就是瓷砖的大小
    matrix:形变
    x:瓷砖之间x轴间距
    y:瓷砖之间y轴艰巨
    tiling:贴瓷砖的方法
    isColored:瓷砖是否添加了yanse
    callbacks:回调方法
    CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 40, 40), CGAffineTransformIdentity, 40, 40, kCGPatternTilingNoDistortion, true, &amp;callBack);
    CGFloat alpha = 1.0;
    //设置图形上下文的填充样式，三个参数为上下文、样式、透明度
    CGContextSetFillPattern(context, pattern, &amp;alpha);
    //绘制图形
    CGContextFillRect(context, rect);

CGPatternRelease(pattern);
CGColorSpaceRelease(colorSpace);
}
//callback方法，在该方法中绘制了自定义样式
void drawTile(void *info,CGContextRef context)
{
    CGContextSetRGBFillColor(context, 235.0/255.0, 127.0/255.0, 175.0/255.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, 20, 20));
    CGContextFillRect(context, CGRectMake(20, 20, 40, 40));

    CGContextSetRGBFillColor(context, 140.0/255.0, 179.0/255.0, 62.0/255.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 20, 20, 20));
    CGContextFillRect(context, CGRectMake(20, 0, 20, 20));
}
</code></pre><p>效果图如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/tianchong1.png" alt="image"></p>
<h3 id="u4F4D_u56FE_u7ED8_u5236"><a href="#u4F4D_u56FE_u7ED8_u5236" class="headerlink" title="位图绘制"></a>位图绘制</h3><p>以上的方法中，我们是在<code>drawRect</code>中通过<code>UIGraphicsGetCurrentContext</code>方法获得的图形上下文，进行的绘制。我们也可以我们也可以在位图活着PDF的上下文中进行绘制。位图上下文和PDF上下文我们需要手动创建方法分别为：<code>UIGraphicsBeginImageContext()</code>和<code>UIGraphicsBeginPDFContextToFile()</code>，使用完后再关闭它。<code>drawRect</code>中的图形上下文是由系统创建的因此只能在该方法中使用，而位图上下文和PDF上下文时我们自己创建的因此可以在任何地方使用。获得刚上下文的方法是在创建上下文之后关闭上下文之前调用<code>UIGraphicsGetCurrentContext()</code>就可以获得我们自己创建的上下文。</p>
<p>下面的代码中我们会创建一个位图上下文，并利用该上下文获得一个圆形的头像图片，以此来对位图绘制进行说明。</p>
<pre><code>- (UIImage *)imageMaker
{
    CGSize size = CGSizeMake(200, 200);
    //创建位图上下文
    UIGraphicsBeginImageContext(size);
    //创建路径
    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 0, 200, 200) cornerRadius:100];
    //路径裁剪
    [path addClip];

    UIImage *image = [UIImage imageNamed:@&quot;boy.jpg&quot;];
    CGSize imageSize = image.size;
    //调整绘制区域
    float ratioX = 200/imageSize.width;
    float ratioY = 200/imageSize.height;
    float ratio = MAX(ratioX, ratioY);

    float originX = (200-ratio*imageSize.width)/2.0;
    float originy = (200-ratio*imageSize.height)/2.0;
    //图片绘制
    [image drawInRect:CGRectMake(originX, originy, ratio*imageSize.width,ratio*imageSize.height)];
    //获得图片
    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
    //关闭位图上下文
    UIGraphicsEndImageContext();

    return newImage;
}
</code></pre><p>效果图如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/weitu.png" alt="image"></p>
<h3 id="PDF_u7ED8_u5236"><a href="#PDF_u7ED8_u5236" class="headerlink" title="PDF绘制"></a>PDF绘制</h3><p>PDF绘制根位图绘制类似，首先要创建PDF图形上下文，不同的是绘制内容到 PDF需要创建分页，每页内容的开始都要调用一次<code>UIGraphicsBeginPDFPage()</code>方法。下面代码中演示了绘制文本及图片到PDF的过程。</p>
<pre><code>- (NSString *)PDFmaker
{
    NSArray *direstories = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *path = [[direstories lastObject] stringByAppendingPathComponent:@&quot;rustPDF.pdf&quot;];

    UIGraphicsBeginPDFContextToFile(path, CGRectZero, [NSDictionary dictionaryWithObjectsAndKeys:@&quot;rust&quot;,kCGPDFContextAuthor, nil]);
    UIGraphicsBeginPDFPage();

    NSString *title = @&quot;This is a PDF&quot;;
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    style.alignment = NSTextAlignmentCenter;
    [title drawInRect:CGRectMake(0, 30, 612, 50) withAttributes:@{NSFontAttributeName:[UIFont systemFontOfSize:18],NSParagraphStyleAttributeName:style}];
    NSString *content = @&quot;this hit,that ice cold,Michelle Pfeiffer,that white gold,this one,for them hood girl,them good girl,straight masterpieces.&quot;;
    NSMutableParagraphStyle *style2 = [[NSMutableParagraphStyle alloc] init];
    style2.alignment = NSTextAlignmentLeft;
    [content drawInRect:CGRectMake(30, 100, 600, 100) withAttributes:@{NSFontAttributeName:[UIFont systemFontOfSize:16],NSForegroundColorAttributeName:[UIColor grayColor],NSParagraphStyleAttributeName:style2}];
    UIImage *image = [UIImage imageNamed:@&quot;boy.jpg&quot;];
    [image drawInRect:CGRectMake(120, 150, 397, 220)];

    UIGraphicsEndPDFContext();

    return path;
}
</code></pre><p>可以利用UIWebView可以将绘制的PDF展现过来。代码如下：</p>
<pre><code>NSString* path = [self PDFmaker];
UIWebView *webview = [[UIWebView alloc] initWithFrame:CGRectMake(0, 64, self.view.bounds.size.width, self.view.bounds.size.height-64)];
[self.view addSubview:webview];

NSURL *url = [NSURL URLWithString:path];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
webview loadRequest:request];
</code></pre><p>效果图如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/pdf.png" alt="image"></p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>本篇博客中以几个效果的视线介绍里Quartz 2D的一些基础知识，若果想要更全面的了解这部分的内容推荐很好的一篇博客：</p>
<p><a href="http://www.cnblogs.com/kenshincui/p/3959951.html" target="_blank" rel="external">iOS开发系列–打造自己的“美图秀秀”</a></p>
<p>另本篇博客中的详细代码可以从github下载<a href="https://github.com/jiliangzhai/RUSTQuartz2DDrawing" target="_blank" rel="external">Demo</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Quartz 2D是Core Graphic框架的一部分，可以用以进行2D图行的绘制。在这篇博客中以几个功能的实现介绍一下Quartz 2D的基础知识。]]>
    
    </summary>
    
      <category term="IOS Quartz2D" scheme="http://rustblogs.com/tags/IOS-Quartz2D/"/>
    
      <category term="ios开发" scheme="http://rustblogs.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ios开发－GCD实现多线程开发]]></title>
    <link href="http://rustblogs.com/2015/12/26/gdc/"/>
    <id>http://rustblogs.com/2015/12/26/gdc/</id>
    <published>2015-12-26T03:07:00.000Z</published>
    <updated>2015-12-28T14:51:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="GCD_u57FA_u7840_u53CA_u5E38_u7528_u65B9_u6CD5"><a href="#GCD_u57FA_u7840_u53CA_u5E38_u7528_u65B9_u6CD5" class="headerlink" title="GCD基础及常用方法"></a>GCD基础及常用方法</h2><p>GCD(Grand Center Dispatch)是c语言开发的一套多线程机制。GCD是一种与块紧密相连的技术，开发者只需要将快排入队列中，GCD会负责处理所有的调度事宜。</p>
<h3 id="GCD_u4E2D_u7684_u4E00_u4E9B_u6982_u5FF5"><a href="#GCD_u4E2D_u7684_u4E00_u4E9B_u6982_u5FF5" class="headerlink" title="GCD中的一些概念"></a>GCD中的一些概念</h3><p><strong>串行(serial)</strong>与<strong>并行(concurrent)</strong></p>
<p> 这两个概念是相关任务能否同时执行的问题，串行执行就是每次只执行一个任务，除被执行的任务外，其余任务处于等待状态，执行的顺序就是任务加入队列的顺序。并行执行可以同时执行多个任务。</p>
<p><strong>同步(synchronous)</strong>与<strong>异步(asynchronous)</strong></p>
<p>这两个概念是有关某一任务完成是否可以立即返回的问题。同步执行需要队列中的所有预定任务都完成后才能返回，并行则不需要某一任务完成后即可返回。</p>
<p><strong>并发</strong>于<strong>并行</strong></p>
<p>并发与并行的区别主要在于是否真正同时执行两个程序，并行是这样的，并发往往是在不同程序间切换，以同时执行多个程序。</p>
<p><strong>主队列</strong></p>
<p>GCD有一个特殊队列就是主队列，用以执行主线程中的任务，UI的更新都应该放到主线程中去执行。</p>
<h3 id="u521B_u5EFA_u961F_u5217"><a href="#u521B_u5EFA_u961F_u5217" class="headerlink" title="创建队列"></a>创建队列</h3><p>创建串行队列的方法如下：</p>
<pre><code>dispatch_queue_t serialQueue =     dispatch_queue_creat(&quot;queueName&quot;,DISPATCH_QUEUE_SERIAL);
</code></pre><p>创建并发队列方法有两种：</p>
<pre><code>dispatch_queue_t serialQueue =     dispatch_queue_creat(&quot;queueName&quot;,DISPATCH_QUEUE_CONCURRENT);
</code></pre><p>或者使用系统提供的全局并发队列：</p>
<pre><code>dispatch_queue_t globlaQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
</code></pre><h3 id="u8C03_u7528_u65B9_u6CD5"><a href="#u8C03_u7528_u65B9_u6CD5" class="headerlink" title="调用方法"></a>调用方法</h3><p>基本调用方法有两种，同步调用和异步调用，区别已经讲过，调用方法如下：</p>
<pre><code>dispatch_async(serialQueue,^{
    //do something
});//异步调用

dispatch_sync(serisalQueue,^{
    //do something
});//同步调用
</code></pre><p>在主线程中使用同步方法提交<code>block</code>，会导致死锁。</p>
<p>其他调用方法:</p>
<pre><code>static dispatch_once_t once;
dispatch_once(&amp;once,^{
    //do something
});
</code></pre><p>只执行1次，重复调用也不会重复执行，常用于单例模式。</p>
<pre><code> dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_SEC*numOfSeconds);
dispatch_after(time, queue, ^{
    //do something
});
</code></pre><p>将任务延迟加入队列，达到延迟执行的效果。</p>
<pre><code>dispatch_suspend(queue);
</code></pre><p>挂起队列，挂起时如有<code>block</code>正在执行，会等<code>block</code>执行后暂停后续的<code>block</code>的执行。</p>
<pre><code>dispatch_resume(queue);
</code></pre><p>恢复任务的执行。</p>
<pre><code>dispatch_apply(size_t iterations, dispatch_queue_t queue, ^(size_t) {
    //do something
});
</code></pre><p>循环执行<code>block</code>，三个参数分别为：循环的次数 队列 要执行的<code>block</code>。只有当循环完成后才回返回，因此会阻塞线程。另要避免<code>dispatch_apply</code>的嵌套使用，会导致死锁。</p>
<pre><code>dispatch_barrier_async(dispatch_queue_t queue, ^{
    //do something
});
dispatch_barrier_sync(dispatch_queue_t queue, ^{
    //do something
});
</code></pre><p>当<code>dispatch_barrier_(a)sync</code>将任务加入队列后如存在已有任务，那么会等到已有任务完成后再执行该任务，并且会阻塞在此<code>block</code>后加入的任务，直至该任务完成。</p>
<p>需要注意的是<code>dispatch_barrier_(a)sync</code>只有在自己创建的并发队列上有以上提及的效果，在串行队列及全局并发队列上效果等同于<code>dispatch_(a)sync</code>。</p>
<pre><code>   dispatch_group_t group = dispatch_group_create();
dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);

dispatch_group_async(group,globalQueue, ^{
    //do something
});

dispatch_group_async(group,globalQueue, ^{
   //do something
});

dispatch_group_notify(group,globalQueue, ^{
    //do something
});
</code></pre><p>用以实现任务的分组执行，加入<code>group</code>的任务都完成后，才会执行<code>dispatch_group_notify()</code>添加的任务。</p>
<p>另外当你无法使用队列变量时，可以使用：</p>
<pre><code>dispatch_group_enter(dispatch_group_t group);
dispatch_group_leave(dispatch_group_t group);
</code></pre><p>将需要加入<code>group</code>的任务打包起来。</p>
<p><code>dispatch_group_notify()</code>中添加的就是结束任务。当然也可以添加等待任务：</p>
<pre><code>dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);
</code></pre><p>该等待任务会在规定的时间内同步等待，直至<code>group</code>中的任务全部完成，或者超过规定时间才返回。</p>
<pre><code>dispatch_set_context(dispatch_object_t object, void *context);
dispatch_get_context(dispatch_object_t object);
</code></pre><p><code>dispatch_set_context</code>可以为队列添加上下文数据，<code>context</code>的参数类型是<code>void *</code>，即可以指向所有的C类型。由于不是对象类型所以会牵扯到释放的问题，可以使用：</p>
<pre><code>dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer);
</code></pre><p>设置”析构函数”，在队列完成后进行资源释放。具体用法可以参考这篇博客：</p>
<p><a href="http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/" target="_blank" rel="external">为GCD绑定NSObject类型上下文数据－利用_bridge_retained(transfer)转移内存管理权</a></p>
<h3 id="u7EBF_u7A0B_u540C_u6B65"><a href="#u7EBF_u7A0B_u540C_u6B65" class="headerlink" title="线程同步"></a>线程同步</h3><p>多线程就会带来资源抢夺的问题，所以需要加锁机制，即当某一线程进入被抢夺资源后该资源被加锁其他线程不能进入，直至解锁。有两种常用的办法， <code>NSLock</code>和<code>@synchronized</code> 代码块。</p>
<pre><code>[_lock lock];
//被抢夺资源
[_lock unlock];

@synchronized{

    //被抢夺资源

}
</code></pre><p>GCD也提供了一种信号量机制用以解决资源抢夺问题，信号量是<code>dispatch_semaphore_t</code>，每当发出一个信号通知<code>signal</code>，信号量 加1，每发送一个等待信号<code>wait</code>信号量减1,信号量大于0时，信号才能执行否则处于等待状态。相关方法如下：</p>
<pre><code>dispatch_semaphore_t sema = dispatch_semaphore_creat(1);//括号内的为信号量初始值
dispatch_semaphore_wait(sema,DISPATCH_TIME_FOREVER);//括号内的第二个参数为等待时间
dispatch_semaphore_signal(sema);
</code></pre><p><code>NSCondition</code>用来控制线程通讯，它本身也实现了<code>NSLocking</code>协议，可以使用<code>lock</code>和<code>unlock</code>方法。也可以使用<code>wait</code>控制使某个线程处于等待状态，知道其他线程调用<code>signal</code>方法，<code>signal</code>会唤醒一个线程，若存在多个线程处于等待状态则随机唤醒一个。<code>broadcast</code>会唤醒所有处于等待的线程。</p>
<h3 id="u6F14_u793A_u4EE3_u7801"><a href="#u6F14_u793A_u4EE3_u7801" class="headerlink" title="演示代码"></a>演示代码</h3><h4 id="u4E32_u884C_u961F_u5217_u540C_u6B65_u52A0_u8F7D_u548C_u5F02_u6B65_u52A0_u8F7D"><a href="#u4E32_u884C_u961F_u5217_u540C_u6B65_u52A0_u8F7D_u548C_u5F02_u6B65_u52A0_u8F7D" class="headerlink" title="串行队列同步加载和异步加载"></a>串行队列同步加载和异步加载</h4><p>这里采用图片加载来进行演示：</p>
<pre><code>- (void)loadImage{

    for (int i=0; i&lt;row*column; i++) {

        NSString *urlStr = [NSString stringWithFormat:@&quot;http://7xpi4l.com1.z0.glb.clouddn.com/menghuan%i.jpg&quot;,i+1];
        urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

        [imageURL addObject:urlStr];
    }

    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;rust_33SerialQueue&quot;, DISPATCH_QUEUE_SERIAL);

    for (int i=0;i&lt;row*column;i++) {

        /* dispatch_sync(serialQueue, ^{

            [self loadImageAtIndex:i];

        }); */

        dispatch_async(serialQueue, ^{

            [self loadImageAtIndex:i];

        }); 

    }

}

- (void)loadImageAtIndex:(NSInteger)index
{
    NSString *str = [imageURL objectAtIndex:index];

    NSData *data = [NSData dataWithContentsOfURL:        [NSURL URLWithString:str]];
    UIImage *image = [UIImage imageWithData:data];

    [self updateImage:image atIndex:index];

}

- (void)updateImage:(UIImage *)image atIndex:    (NSInteger)index
{
    UIImageView *imageView = [imageViews     objectAtIndex:index];

    dispatch_async(dispatch_get_main_queue(), ^{

        imageView.image = image;

    });
}
</code></pre><p>串行同步加载的效果如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif07.gif" alt="serialImages"></p>
<p>串行异步加载的效果如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif06.gif" alt="serialImages"></p>
<p>12张图片依次加载，区别在于同步调用会在所有图片加载完成后才返回，异步调用则不会。</p>
<h3 id="u5E76_u53D1_u5F02_u6B65_u8C03_u7528"><a href="#u5E76_u53D1_u5F02_u6B65_u8C03_u7528" class="headerlink" title="并发异步调用"></a>并发异步调用</h3><p>代码于上面的代码相似，<code>loadImage</code>方法不同。</p>
<pre><code>- (void)loadImage{

    for (int i=0; i&lt;row*column; i++) {

        NSString *urlStr = [NSString stringWithFormat:@&quot;http://7xpi4l.com1.z0.glb.clouddn.com/menghuan%i.jpg&quot;,i+1];
        urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

        [imageURL addObject:urlStr];
    }

    dispatch_queue_t globalQueue =     dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    for (int i=0;i&lt;row*column;i++) {

        dispatch_async(globalQueue, ^{

            [self loadImageAtIndex:i];

        });

    }

}
</code></pre><p>效果如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif01.gif" alt="loadImageInConcerrent"></p>
<h4 id="u4EFB_u52A1_u6267_u884C_u4E2D_u7684_u987A_u5E8F_u63A7_u5236"><a href="#u4EFB_u52A1_u6267_u884C_u4E2D_u7684_u987A_u5E8F_u63A7_u5236" class="headerlink" title="任务执行中的顺序控制"></a>任务执行中的顺序控制</h4><p>利用<code>dispatch_barrier_async</code>可以控制执行顺序。该方法创建的任务会先查看队列中有无任务要执行，如果有则会等待任务执行完毕后再执行，同时再此方法后创建的任务都不洗等待该任务完成后才能得以执行。下面演示一下该效果，与上面的代码不同的部分是加载方法。</p>
<pre><code>- (void)loadImage {

    for (int i=0; i&lt;row*column; i++) {

        NSString *urlStr = [NSString stringWithFormat:@&quot;http://7xpi4l.com1.z0.glb.clouddn.com/menghuan%i.jpg&quot;,i+1];
        urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

        [imageURL addObject:urlStr];
    }

    dispatch_queue_t globalQueue = dispatch_queue_create(&quot;rustblogs&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_barrier_async(globalQueue, ^{

        [self loadImageAtIndex:11];
    });

    for (int i=0;i&lt;row*column-1;i++) {

        dispatch_async(globalQueue, ^{

            [self loadImageAtIndex:i];

        });
    }

}
</code></pre><p>在代码中我们规定先加载最后一张图片再加载前十一张。效果如图：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif08.gif" alt="loadImageWithControl"></p>
<h4 id="u4EFB_u52A1_u7684_u5206_u7EC4_u7BA1_u7406"><a href="#u4EFB_u52A1_u7684_u5206_u7EC4_u7BA1_u7406" class="headerlink" title="任务的分组管理"></a>任务的分组管理</h4><pre><code>- (void)loadImage
{
    for (int i=0; i&lt;row*column; i++) {

        NSString *urlStr = [NSString stringWithFormat:@&quot;http://7xpi4l.com1.z0.glb.clouddn.com/menghuan%i.jpg&quot;,i+1];
        urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

        [imageURL addObject:urlStr];
    }

    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);
    dispatch_group_async(group,globalQueue, ^{

        for (int i=0; i&lt;6; i++) {
            [self loadImageAtIndex:i];
        }

    });

    dispatch_group_async(group,globalQueue, ^{
        for (int i=3; i&lt;9; i++) {
            [self loadImageAtIndex:i];
        }
    });

    dispatch_group_notify(group,globalQueue, ^{

        for (int i=9; i&lt;12; i++) {
            [self loadImageAtIndex:i];
        }
    });
}
</code></pre><p>代码中我门将12张图片的加载分成3个部分第一次加载6张图片，第二次加载3张图片，将两次任务放入<code>group</code>中,<code>group</code>中的任务完成后再加载最后3张图片。效果如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif09.gif" alt="loadImageWithControl"></p>
<h4 id="NSCondition_u7684_u4F7F_u7528"><a href="#NSCondition_u7684_u4F7F_u7528" class="headerlink" title="NSCondition的使用"></a>NSCondition的使用</h4><pre><code>- (void)loadImage
{

    for (int i=0; i&lt;row*column; i++) {

        NSString *urlStr = [NSString stringWithFormat:@&quot;http://7xpi4l.com1.z0.glb.clouddn.com/menghuan%i.jpg&quot;,i+1];
        urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

        [imageURL addObject:urlStr];
    }

    for (int i=0; i&lt;15; i++) {

        dispatch_async(dispatch_get_global_queue(0, 0), ^{

            [self getData];

        });

    }

}

- (void)getData
{
    [condition lock];

    [condition wait];
    count++;
    [condition unlock];

    if (imageURL.count&gt;0) {
        [self loadImageAtIndex:count];
    }

}

- (void)loadImageAtIndex:(NSInteger)index
{

    UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:[imageURL lastObject]]]];
    UIImageView *imageView = [imageViews objectAtIndex:index];
    dispatch_async(dispatch_get_main_queue(), ^{

            imageView.image = image;

    });
    [imageURL removeLastObject];

}

- (void)creatImage
{
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        [condition signal];
    });
}
</code></pre><p><code>loadImage</code>创建15个线程执行<code>getData</code>,于<code>NSLock</code>不同的是当进入锁中的线程处于 <code>wait</code>状态时其他线程是可以进入锁中的。<code>creatImage</code>会发出<code>signal</code>信号。随机唤醒一个线程进行图片加载和UI更新。效果如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif11.gif" alt="loadImageWithControl"></p>
<h3 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h3><p>本片博客就是以上内容，详细代码在<a href="https://github.com/jiliangzhai/RUSTGCDDemo" target="_blank" rel="external">DEMO</a>中，有兴趣的同学可以下载看一下，最后推荐两个博客。本篇中的一些内容也是参考这两篇博客。</p>
<p><a href="http://www.cnblogs.com/kenshincui/p/3983982.html#GCD" target="_blank" rel="external">iOS开发系列–并行开发其实很容易</a></p>
<p><a href="http://tutuge.me/2015/04/03/something-about-gcd/" target="_blank" rel="external">GCD使用经验与技巧浅谈</a></p>
]]></content>
    <summary type="html">
    <![CDATA[用户在使用程序时期望最小的等待时间，多线程技术有利于充分发挥处理器性能，提高运行效率并能解决线程阻塞的问题。常用的多线程开发有三种方式：NSTread NSOperation GCD。在这篇博客中我们学习的是GCD,这也是目前比较推荐的方式。]]>
    
    </summary>
    
      <category term="ios GCD" scheme="http://rustblogs.com/tags/ios-GCD/"/>
    
      <category term="ios开发" scheme="http://rustblogs.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <link href="http://rustblogs.com/2015/12/21/friestblog/"/>
    <id>http://rustblogs.com/2015/12/21/friestblog/</id>
    <published>2015-12-21T14:46:40.000Z</published>
    <updated>2015-12-23T11:30:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5229_u7528hexo_u642D_u5EFA_u535A_u5BA2"><a href="#u5229_u7528hexo_u642D_u5EFA_u535A_u5BA2" class="headerlink" title="利用hexo搭建博客"></a>利用hexo搭建博客</h2><p>本博客是利用hexo+github+七牛做图床搭建的，并绑定了个人域名至guthub，使用的主题名是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">next</a>。</p>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>安装hexo,需要Node,安装Node后在终端输入命令：</p>
<p><code>npm install -g hexo</code></p>
<p><code>hexo init</code></p>
<p>即可安装。</p>
<p>hexo常用命令：</p>
<p><code>hexo new &quot;postName&quot;</code> //新建文章</p>
<p><code>hexo server</code> // 启用本地服务</p>
<p><code>hexo clean</code> //清除缓存</p>
<p><code>hexo g</code> //生成静态网页</p>
<p><code>hexo d</code> //开始部署</p>
<p>博客内容使用Markdown进行编写，推荐MOU编辑器。</p>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>github账号很多人都会有，需要做的就是建立一个名为userName.github.io的仓库，然后在你的博客根目录的_config.yml中进行配置就OK啦。</p>
<h3 id="u56FE_u5E8A"><a href="#u56FE_u5E8A" class="headerlink" title="图床"></a>图床</h3><p>我使用的是七牛云储存，大致过程为申请账号，建立空间，同步本地文件至空间，然后就可以使用外链了。<br>同步本地文件至空间使用的是qrsync同步工具，具体教程可以看这篇文章：<a href="http://www.douban.com/note/526859806/" target="_blank" rel="external">如何使用七牛云做为图床</a>。</p>
<h3 id="u4E3B_u9898"><a href="#u4E3B_u9898" class="headerlink" title="主题"></a>主题</h3><p>本博客使用的是 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">next</a>，比较简洁，作者写的配置信息很详细，有兴趣的同学可以看一下。</p>
<h3 id="u7B2C_u4E00_u7BC7_u535A_u5BA2_u7684_u7ED3_u675F_u8BED"><a href="#u7B2C_u4E00_u7BC7_u535A_u5BA2_u7684_u7ED3_u675F_u8BED" class="headerlink" title="第一篇博客的结束语"></a>第一篇博客的结束语</h3><p>博客搭建的过程大概就是这些了，本人IOS开发菜鸟目前还在机械行业工作，博客以后的内容主要会以IOS开发为主，还会有学习相关知识的内容。希望自己加油。</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/boy.jpg" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[开博第一篇博客，理所当然的要总结一下博客的搭建过程，利用hexo搭建个人博客在网上有很多详细的教程，在这里就不多赘述，仅大致描述一下。]]>
    
    </summary>
    
      <category term="hexo blog" scheme="http://rustblogs.com/tags/hexo-blog/"/>
    
      <category term="杂" scheme="http://rustblogs.com/categories/%E6%9D%82/"/>
    
  </entry>
  
</feed>
