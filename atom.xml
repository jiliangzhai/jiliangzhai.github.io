<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[生锈的车轮]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://rustblogs.com/"/>
  <updated>2016-01-06T15:15:04.000Z</updated>
  <id>http://rustblogs.com/</id>
  
  <author>
    <name><![CDATA[rust_33]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Quartz 2D图形绘制基础]]></title>
    <link href="http://rustblogs.com/2016/01/06/quartz2D/"/>
    <id>http://rustblogs.com/2016/01/06/quartz2D/</id>
    <published>2016-01-06T12:30:33.000Z</published>
    <updated>2016-01-06T15:15:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Quartz_2D_u56FE_u884C_u7ED8_u5236_u57FA_u7840"><a href="#Quartz_2D_u56FE_u884C_u7ED8_u5236_u57FA_u7840" class="headerlink" title="Quartz 2D图行绘制基础"></a>Quartz 2D图行绘制基础</h2><p>Quartz 2D是Core Graphic框架的一部分，可以用以进行2D图行的绘制。在这篇博客中以几个功能的实现介绍一下Quartz 2D的基础知识。<br> 在这篇博客中我们将涉及到的功能包括：</p>
<ol>
<li>基础图形的绘制</li>
<li>渐变填充</li>
<li>图形上下文的形变</li>
<li>填充模式</li>
<li>位图绘制</li>
<li>PDF绘制</li>
</ol>
<h3 id="u57FA_u7840_u56FE_u5F62_u7ED8_u5236"><a href="#u57FA_u7840_u56FE_u5F62_u7ED8_u5236" class="headerlink" title="基础图形绘制"></a>基础图形绘制</h3><p>首先要介绍最简单的基础图形绘制，包括直线、曲线、矩形、圆形等。利用基础图形的绘制我们可以对绘图流程有所了解。<br>绘制过程大致可分为以下几个步骤：</p>
<ol>
<li>获取图形上下文</li>
<li>构建路径</li>
<li>加入路径至图形上下文</li>
<li>设置图形上下文想干参数，包括颜色、线条、阴影等。</li>
<li>进行绘制</li>
</ol>
<p>在UI控件的<code>drawRect</code>方法中我们可以通过<code>UIGraphicsGetCurrentContext()</code>方法获得当前的图形上下文，然后在该图形上下文中进行绘制。下面以最简单的线条绘制进行说明。</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得图形上下文
    CGContextRef context = UIGraphicsGetCurrentContext();
    //创建路径
    CGMutablePathRef path = CGPathCreateMutable();
    //线段的起始点
    CGPathMoveToPoint(path, nil, 10, 124);
    //线段终点
    CGPathAddLineToPoint(path, nil, self.bounds.size.width-10,124);
    //添加第二条线
    CGPathAddLineToPoint(path, nil, self.bounds.size.width/2, 164);
    //添加第三条线
    CGPathAddLineToPoint(path, nil, 10, 124);
    //将路径添加到上下文
    CGContextAddPath(context, path);
    //设置线的端点形状
    CGContextSetLineCap(context, kCGLineCapButt);
    //设置交点形状
    CGContextSetLineJoin(context, kCGLineJoinRound);
    //设置线条宽度
    CGContextSetLineWidth(context, 3.0);
    //设置线条颜色，在这里需要将UIColorz转化为CGColor
    CGContextSetStrokeColorWithColor(context, [UIColor redColor].CGColor);
    //进行绘制，第二个参数可以选择填充、绘制边框或两者都绘制
    CGContextDrawPath(context, kCGPathStroke);
    //由于Quartz 2D 属于Core Graphics框架所以对创建的对象要自己给释放掉。带有creat copy字样创建的对象都需要我们自己释放。
    CGPathRelease(path);
}
</code></pre><p>以上就是绘制图形的基本过程，需要注意的是对象的释放部分不要忘记。</p>
<h3 id="u6E10_u53D8_u8272_u586B_u5145"><a href="#u6E10_u53D8_u8272_u586B_u5145" class="headerlink" title="渐变色填充"></a>渐变色填充</h3><p>渐变色的视线需要我们在填充区域的不同位置（以0-1的某个数值表示）进行颜色的设置，设置的颜色之间的区域系统会进行补充。大致过程如下：</p>
<ol>
<li>确定使用的颜色空间，比如RGB、CMYK或者Gray。</li>
<li>确定填充区域某些位置的颜色。</li>
<li>构建<code>CGContextGradientRef</code>。</li>
<li>进行填充，按照填充的方向不同，有两种调用方式线性渐变和径向渐变。</li>
</ol>
<p>以RGB为例，一个颜色由4个数值决定{red,green,blue,alpha}。下面的代码演示了使用RGB颜色空间进行线性渐变和径向渐变。</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    CGContextRef context = UIGraphicsGetCurrentContext();

    {
        //储存当先图形上下文状态
        CGContextSaveGState(context);
        //裁减图形上下文
        CGContextClipToRect(context, CGRectMake((rect.size.width-200)/2, 84, 200, 200));
        //构建颜色空间，这里选择RGB
        CGColorSpaceRef colorSpace =     CGColorSpaceCreateDeviceRGB();
        //创建3个颜色
        CGFloat component[12] = {191.0/255.0,21.0/255.0,133.0/255.0,1,218.0/255.0,112.0/255.0,214.0/255.0,1.0,216.0/255.0,191.0/255.0,216.0/255.0,1.0};
        //3个颜色对应的填充区域的位置
        CGFloat locations[3] = {0,0.3,1.0};
        //创建CGGradientRef
        CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, component, locations, 3);
        //确定起始点和终点，选择进行线性渐变
        //kCGGradientDrawsAfterEndLocation表征开始位置之前不进行填充，结束位置后继续填充
        //kCGGradientDrawsBeforeStartLocation表征开始位置之前进行填充，结束位置后不进行填充
        CGContextDrawLinearGradient(context, gradient, CGPointMake(0,0), CGPointMake(200,200), kCGGradientDrawsAfterEndLocation);
        //恢复图形上下文状态
        CGContextRestoreGState(context);
        //对象释放
        CGColorSpaceRelease(colorSpace);
        CGGradientRelease(gradient);
    }

    {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGFloat component[12] = {191.0/255.0,21.0/255.0,133.0/255.0,1,218.0/255.0,112.0/255.0,214.0/255.0,1.0,216.0/255.0,191.0/255.0,216.0/255.0,1.0};
        CGFloat locations[3] = {0,0.3,1.0};
        CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, component, locations, 3);
        //确定起始起始半径，结束位置结束半径，选择进行径向填充。
        CGContextDrawRadialGradient(context, gradient, CGPointMake(rect.size.width/2,404 ), 0, CGPointMake(rect.size.width/2, 404), 100, kCGGradientDrawsBeforeStartLocation);

        CGColorSpaceRelease(colorSpace);
        CGGradientRelease(gradient);
    }

}
</code></pre><p>上面代码中的<code>CGContextSaveGState(context)``CGContextRestoreGState(context)</code>分别是储存和恢复图形上下文状态，由于在线性渐变中我对上下文进行了裁剪<code>CGContextClipToRect()</code>，而在径向渐变中不想上下文中只有被裁剪过的区域所以在裁剪前存储了图形上下文，在使用后又恢复来它。效果图如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/jianbian.png" alt="image"></p>
<h3 id="u56FE_u5F62_u4E0A_u4E0B_u6587_u5F62_u53D8"><a href="#u56FE_u5F62_u4E0A_u4E0B_u6587_u5F62_u53D8" class="headerlink" title="图形上下文形变"></a>图形上下文形变</h3><p>图形上下文的形变包括，平移、放缩以及绕z轴的旋转，Quartz 2D的坐标原点在左下角，单UIKit对其进行了变换，统一在了屏幕左上角，所以下面的变换是基于左上角的原点的，这一点需要注意。另外在做图形上下文变换前最好进行图形上下文状态的储存，使用完后恢复状态，以便再次使用。下面以一个图像的绘制对图形上下文的变换进行说明，代码如下：</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    CGContextRef context = UIGraphicsGetCurrentContext();

    CGContextSaveGState(context);
//平移
    CGContextTranslateCTM(context,90, 50);
//缩小
    CGContextScaleCTM(context, 0.8,0.8);
//旋转
    CGContextRotateCTM(context, M_PI_4/4);

    UIImage *image = [UIImage imageNamed:@&quot;boy.jpg&quot;];
//在上下文中绘制图像
    [image drawInRect:CGRectMake(0, 74, 240, 180)];

    CGContextRestoreGState(context);
}    
</code></pre><p>效果图如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/xingbian.png" alt="image"></p>
<h3 id="u586B_u5145_u6A21_u5F0F"><a href="#u586B_u5145_u6A21_u5F0F" class="headerlink" title="填充模式"></a>填充模式</h3><p>我们可以自定义一种样式进行填充，类似于贴瓷砖，我们定义的样式就是瓷砖的样式。然后以全都一样的瓷砖去铺满要填充的区域。</p>
<p>Quartz 2D支持两种填充模式，有颜色填充和无颜色填充。这里使用有颜色填充进行功能的演示。过程如下：</p>
<ol>
<li>创建一个填充的颜色空间</li>
<li>构建自定义样式，即瓷砖的样式，创建时需要构建一个一个callback方法，在该方法中绘制自定义样式。</li>
<li>使用CGPatternCreate方法创建一个填充模式</li>
<li>设定图形上下文的填充模式</li>
<li>绘制图形</li>
</ol>
<p>下面通过代码及效果图对填充模式进行说明。</p>
<pre><code>- (void)drawRect:(CGRect)rect
{
    CGContextRef context = UIGraphicsGetCurrentContext();
    //创建填充的颜色空间
    CGColorSpaceRef colorSpace = CGColorSpaceCreatePattern(NULL);
    CGContextSetFillColorSpace(context, colorSpace);
    //callback方法
    CGPatternCallbacks callBack = {0,&amp;drawTile,NULL};
    //根据callback方法创建自定义样式
    CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 40, 40), CGAffineTransformIdentity, 40, 40, kCGPatternTilingNoDistortion, true, &amp;callBack);
    CGFloat alpha = 1.0;
    //设置图形上下文的填充样式
    CGContextSetFillPattern(context, pattern, &amp;alpha);
    //绘制图形
    CGContextFillRect(context, rect);

CGPatternRelease(pattern);
CGColorSpaceRelease(colorSpace);
}
//callback方法，在该方法中绘制了自定义样式
void drawTile(void *info,CGContextRef context)
{
    CGContextSetRGBFillColor(context, 235.0/255.0, 127.0/255.0, 175.0/255.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, 20, 20));
    CGContextFillRect(context, CGRectMake(20, 20, 40, 40));

    CGContextSetRGBFillColor(context, 140.0/255.0, 179.0/255.0, 62.0/255.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 20, 20, 20));
    CGContextFillRect(context, CGRectMake(20, 0, 20, 20));
}
</code></pre><p>效果图如下：<br><img src="http://7xpcyy.com1.z0.glb.clouddn.com/tianchong.png" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[Quartz 2D是Core Graphic框架的一部分，可以用以进行2D图行的绘制。在这篇博客中以几个功能的实现介绍一下Quartz 2D的基础知识。]]>
    
    </summary>
    
      <category term="IOS Quartz2D" scheme="http://rustblogs.com/tags/IOS-Quartz2D/"/>
    
      <category term="IOS" scheme="http://rustblogs.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ios开发－GCD实现多线程开发]]></title>
    <link href="http://rustblogs.com/2015/12/26/gdc/"/>
    <id>http://rustblogs.com/2015/12/26/gdc/</id>
    <published>2015-12-26T03:07:00.000Z</published>
    <updated>2015-12-28T14:51:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="GCD_u57FA_u7840_u53CA_u5E38_u7528_u65B9_u6CD5"><a href="#GCD_u57FA_u7840_u53CA_u5E38_u7528_u65B9_u6CD5" class="headerlink" title="GCD基础及常用方法"></a>GCD基础及常用方法</h2><p>GCD(Grand Center Dispatch)是c语言开发的一套多线程机制。GCD是一种与块紧密相连的技术，开发者只需要将快排入队列中，GCD会负责处理所有的调度事宜。</p>
<h3 id="GCD_u4E2D_u7684_u4E00_u4E9B_u6982_u5FF5"><a href="#GCD_u4E2D_u7684_u4E00_u4E9B_u6982_u5FF5" class="headerlink" title="GCD中的一些概念"></a>GCD中的一些概念</h3><p><strong>串行(serial)</strong>与<strong>并行(concurrent)</strong></p>
<p> 这两个概念是相关任务能否同时执行的问题，串行执行就是每次只执行一个任务，除被执行的任务外，其余任务处于等待状态，执行的顺序就是任务加入队列的顺序。并行执行可以同时执行多个任务。</p>
<p><strong>同步(synchronous)</strong>与<strong>异步(asynchronous)</strong></p>
<p>这两个概念是有关某一任务完成是否可以立即返回的问题。同步执行需要队列中的所有预定任务都完成后才能返回，并行则不需要某一任务完成后即可返回。</p>
<p><strong>并发</strong>于<strong>并行</strong></p>
<p>并发与并行的区别主要在于是否真正同时执行两个程序，并行是这样的，并发往往是在不同程序间切换，以同时执行多个程序。</p>
<p><strong>主队列</strong></p>
<p>GCD有一个特殊队列就是主队列，用以执行主线程中的任务，UI的更新都应该放到主线程中去执行。</p>
<h3 id="u521B_u5EFA_u961F_u5217"><a href="#u521B_u5EFA_u961F_u5217" class="headerlink" title="创建队列"></a>创建队列</h3><p>创建串行队列的方法如下：</p>
<pre><code>dispatch_queue_t serialQueue =     dispatch_queue_creat(&quot;queueName&quot;,DISPATCH_QUEUE_SERIAL);
</code></pre><p>创建并发队列方法有两种：</p>
<pre><code>dispatch_queue_t serialQueue =     dispatch_queue_creat(&quot;queueName&quot;,DISPATCH_QUEUE_CONCURRENT);
</code></pre><p>或者使用系统提供的全局并发队列：</p>
<pre><code>dispatch_queue_t globlaQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
</code></pre><h3 id="u8C03_u7528_u65B9_u6CD5"><a href="#u8C03_u7528_u65B9_u6CD5" class="headerlink" title="调用方法"></a>调用方法</h3><p>基本调用方法有两种，同步调用和异步调用，区别已经讲过，调用方法如下：</p>
<pre><code>dispatch_async(serialQueue,^{
    //do something
});//异步调用

dispatch_sync(serisalQueue,^{
    //do something
});//同步调用
</code></pre><p>在主线程中使用同步方法提交<code>block</code>，会导致死锁。</p>
<p>其他调用方法:</p>
<pre><code>static dispatch_once_t once;
dispatch_once(&amp;once,^{
    //do something
});
</code></pre><p>只执行1次，重复调用也不会重复执行，常用于单例模式。</p>
<pre><code> dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_SEC*numOfSeconds);
dispatch_after(time, queue, ^{
    //do something
});
</code></pre><p>将任务延迟加入队列，达到延迟执行的效果。</p>
<pre><code>dispatch_suspend(queue);
</code></pre><p>挂起队列，挂起时如有<code>block</code>正在执行，会等<code>block</code>执行后暂停后续的<code>block</code>的执行。</p>
<pre><code>dispatch_resume(queue);
</code></pre><p>恢复任务的执行。</p>
<pre><code>dispatch_apply(size_t iterations, dispatch_queue_t queue, ^(size_t) {
    //do something
});
</code></pre><p>循环执行<code>block</code>，三个参数分别为：循环的次数 队列 要执行的<code>block</code>。只有当循环完成后才回返回，因此会阻塞线程。另要避免<code>dispatch_apply</code>的嵌套使用，会导致死锁。</p>
<pre><code>dispatch_barrier_async(dispatch_queue_t queue, ^{
    //do something
});
dispatch_barrier_sync(dispatch_queue_t queue, ^{
    //do something
});
</code></pre><p>当<code>dispatch_barrier_(a)sync</code>将任务加入队列后如存在已有任务，那么会等到已有任务完成后再执行该任务，并且会阻塞在此<code>block</code>后加入的任务，直至该任务完成。</p>
<p>需要注意的是<code>dispatch_barrier_(a)sync</code>只有在自己创建的并发队列上有以上提及的效果，在串行队列及全局并发队列上效果等同于<code>dispatch_(a)sync</code>。</p>
<pre><code>   dispatch_group_t group = dispatch_group_create();
dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);

dispatch_group_async(group,globalQueue, ^{
    //do something
});

dispatch_group_async(group,globalQueue, ^{
   //do something
});

dispatch_group_notify(group,globalQueue, ^{
    //do something
});
</code></pre><p>用以实现任务的分组执行，加入<code>group</code>的任务都完成后，才会执行<code>dispatch_group_notify()</code>添加的任务。</p>
<p>另外当你无法使用队列变量时，可以使用：</p>
<pre><code>dispatch_group_enter(dispatch_group_t group);
dispatch_group_leave(dispatch_group_t group);
</code></pre><p>将需要加入<code>group</code>的任务打包起来。</p>
<p><code>dispatch_group_notify()</code>中添加的就是结束任务。当然也可以添加等待任务：</p>
<pre><code>dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);
</code></pre><p>该等待任务会在规定的时间内同步等待，直至<code>group</code>中的任务全部完成，或者超过规定时间才返回。</p>
<pre><code>dispatch_set_context(dispatch_object_t object, void *context);
dispatch_get_context(dispatch_object_t object);
</code></pre><p><code>dispatch_set_context</code>可以为队列添加上下文数据，<code>context</code>的参数类型是<code>void *</code>，即可以指向所有的C类型。由于不是对象类型所以会牵扯到释放的问题，可以使用：</p>
<pre><code>dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer);
</code></pre><p>设置”析构函数”，在队列完成后进行资源释放。具体用法可以参考这篇博客：</p>
<p><a href="http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/" target="_blank" rel="external">为GCD绑定NSObject类型上下文数据－利用_bridge_retained(transfer)转移内存管理权</a></p>
<h3 id="u7EBF_u7A0B_u540C_u6B65"><a href="#u7EBF_u7A0B_u540C_u6B65" class="headerlink" title="线程同步"></a>线程同步</h3><p>多线程就会带来资源抢夺的问题，所以需要加锁机制，即当某一线程进入被抢夺资源后该资源被加锁其他线程不能进入，直至解锁。有两种常用的办法， <code>NSLock</code>和<code>@synchronized</code> 代码块。</p>
<pre><code>[_lock lock];
//被抢夺资源
[_lock unlock];

@synchronized{

    //被抢夺资源

}
</code></pre><p>GCD也提供了一种信号量机制用以解决资源抢夺问题，信号量是<code>dispatch_semaphore_t</code>，每当发出一个信号通知<code>signal</code>，信号量 加1，每发送一个等待信号<code>wait</code>信号量减1,信号量大于0时，信号才能执行否则处于等待状态。相关方法如下：</p>
<pre><code>dispatch_semaphore_t sema = dispatch_semaphore_creat(1);//括号内的为信号量初始值
dispatch_semaphore_wait(sema,DISPATCH_TIME_FOREVER);//括号内的第二个参数为等待时间
dispatch_semaphore_signal(sema);
</code></pre><p><code>NSCondition</code>用来控制线程通讯，它本身也实现了<code>NSLocking</code>协议，可以使用<code>lock</code>和<code>unlock</code>方法。也可以使用<code>wait</code>控制使某个线程处于等待状态，知道其他线程调用<code>signal</code>方法，<code>signal</code>会唤醒一个线程，若存在多个线程处于等待状态则随机唤醒一个。<code>broadcast</code>会唤醒所有处于等待的线程。</p>
<h3 id="u6F14_u793A_u4EE3_u7801"><a href="#u6F14_u793A_u4EE3_u7801" class="headerlink" title="演示代码"></a>演示代码</h3><h4 id="u4E32_u884C_u961F_u5217_u540C_u6B65_u52A0_u8F7D_u548C_u5F02_u6B65_u52A0_u8F7D"><a href="#u4E32_u884C_u961F_u5217_u540C_u6B65_u52A0_u8F7D_u548C_u5F02_u6B65_u52A0_u8F7D" class="headerlink" title="串行队列同步加载和异步加载"></a>串行队列同步加载和异步加载</h4><p>这里采用图片加载来进行演示：</p>
<pre><code>- (void)loadImage{

    for (int i=0; i&lt;row*column; i++) {

        NSString *urlStr = [NSString stringWithFormat:@&quot;http://7xpi4l.com1.z0.glb.clouddn.com/menghuan%i.jpg&quot;,i+1];
        urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

        [imageURL addObject:urlStr];
    }

    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;rust_33SerialQueue&quot;, DISPATCH_QUEUE_SERIAL);

    for (int i=0;i&lt;row*column;i++) {

        /* dispatch_sync(serialQueue, ^{

            [self loadImageAtIndex:i];

        }); */

        dispatch_async(serialQueue, ^{

            [self loadImageAtIndex:i];

        }); 

    }

}

- (void)loadImageAtIndex:(NSInteger)index
{
    NSString *str = [imageURL objectAtIndex:index];

    NSData *data = [NSData dataWithContentsOfURL:        [NSURL URLWithString:str]];
    UIImage *image = [UIImage imageWithData:data];

    [self updateImage:image atIndex:index];

}

- (void)updateImage:(UIImage *)image atIndex:    (NSInteger)index
{
    UIImageView *imageView = [imageViews     objectAtIndex:index];

    dispatch_async(dispatch_get_main_queue(), ^{

        imageView.image = image;

    });
}
</code></pre><p>串行同步加载的效果如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif07.gif" alt="serialImages"></p>
<p>串行异步加载的效果如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif06.gif" alt="serialImages"></p>
<p>12张图片依次加载，区别在于同步调用会在所有图片加载完成后才返回，异步调用则不会。</p>
<h3 id="u5E76_u53D1_u5F02_u6B65_u8C03_u7528"><a href="#u5E76_u53D1_u5F02_u6B65_u8C03_u7528" class="headerlink" title="并发异步调用"></a>并发异步调用</h3><p>代码于上面的代码相似，<code>loadImage</code>方法不同。</p>
<pre><code>- (void)loadImage{

    for (int i=0; i&lt;row*column; i++) {

        NSString *urlStr = [NSString stringWithFormat:@&quot;http://7xpi4l.com1.z0.glb.clouddn.com/menghuan%i.jpg&quot;,i+1];
        urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

        [imageURL addObject:urlStr];
    }

    dispatch_queue_t globalQueue =     dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    for (int i=0;i&lt;row*column;i++) {

        dispatch_async(globalQueue, ^{

            [self loadImageAtIndex:i];

        });

    }

}
</code></pre><p>效果如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif01.gif" alt="loadImageInConcerrent"></p>
<h4 id="u4EFB_u52A1_u6267_u884C_u4E2D_u7684_u987A_u5E8F_u63A7_u5236"><a href="#u4EFB_u52A1_u6267_u884C_u4E2D_u7684_u987A_u5E8F_u63A7_u5236" class="headerlink" title="任务执行中的顺序控制"></a>任务执行中的顺序控制</h4><p>利用<code>dispatch_barrier_async</code>可以控制执行顺序。该方法创建的任务会先查看队列中有无任务要执行，如果有则会等待任务执行完毕后再执行，同时再此方法后创建的任务都不洗等待该任务完成后才能得以执行。下面演示一下该效果，与上面的代码不同的部分是加载方法。</p>
<pre><code>- (void)loadImage {

    for (int i=0; i&lt;row*column; i++) {

        NSString *urlStr = [NSString stringWithFormat:@&quot;http://7xpi4l.com1.z0.glb.clouddn.com/menghuan%i.jpg&quot;,i+1];
        urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

        [imageURL addObject:urlStr];
    }

    dispatch_queue_t globalQueue = dispatch_queue_create(&quot;rustblogs&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_barrier_async(globalQueue, ^{

        [self loadImageAtIndex:11];
    });

    for (int i=0;i&lt;row*column-1;i++) {

        dispatch_async(globalQueue, ^{

            [self loadImageAtIndex:i];

        });
    }

}
</code></pre><p>在代码中我们规定先加载最后一张图片再加载前十一张。效果如图：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif08.gif" alt="loadImageWithControl"></p>
<h4 id="u4EFB_u52A1_u7684_u5206_u7EC4_u7BA1_u7406"><a href="#u4EFB_u52A1_u7684_u5206_u7EC4_u7BA1_u7406" class="headerlink" title="任务的分组管理"></a>任务的分组管理</h4><pre><code>- (void)loadImage
{
    for (int i=0; i&lt;row*column; i++) {

        NSString *urlStr = [NSString stringWithFormat:@&quot;http://7xpi4l.com1.z0.glb.clouddn.com/menghuan%i.jpg&quot;,i+1];
        urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

        [imageURL addObject:urlStr];
    }

    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);
    dispatch_group_async(group,globalQueue, ^{

        for (int i=0; i&lt;6; i++) {
            [self loadImageAtIndex:i];
        }

    });

    dispatch_group_async(group,globalQueue, ^{
        for (int i=3; i&lt;9; i++) {
            [self loadImageAtIndex:i];
        }
    });

    dispatch_group_notify(group,globalQueue, ^{

        for (int i=9; i&lt;12; i++) {
            [self loadImageAtIndex:i];
        }
    });
}
</code></pre><p>代码中我门将12张图片的加载分成3个部分第一次加载6张图片，第二次加载3张图片，将两次任务放入<code>group</code>中,<code>group</code>中的任务完成后再加载最后3张图片。效果如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif09.gif" alt="loadImageWithControl"></p>
<h4 id="NSCondition_u7684_u4F7F_u7528"><a href="#NSCondition_u7684_u4F7F_u7528" class="headerlink" title="NSCondition的使用"></a>NSCondition的使用</h4><pre><code>- (void)loadImage
{

    for (int i=0; i&lt;row*column; i++) {

        NSString *urlStr = [NSString stringWithFormat:@&quot;http://7xpi4l.com1.z0.glb.clouddn.com/menghuan%i.jpg&quot;,i+1];
        urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

        [imageURL addObject:urlStr];
    }

    for (int i=0; i&lt;15; i++) {

        dispatch_async(dispatch_get_global_queue(0, 0), ^{

            [self getData];

        });

    }

}

- (void)getData
{
    [condition lock];

    [condition wait];
    count++;
    [condition unlock];

    if (imageURL.count&gt;0) {
        [self loadImageAtIndex:count];
    }

}

- (void)loadImageAtIndex:(NSInteger)index
{

    UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:[imageURL lastObject]]]];
    UIImageView *imageView = [imageViews objectAtIndex:index];
    dispatch_async(dispatch_get_main_queue(), ^{

            imageView.image = image;

    });
    [imageURL removeLastObject];

}

- (void)creatImage
{
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        [condition signal];
    });
}
</code></pre><p><code>loadImage</code>创建15个线程执行<code>getData</code>,于<code>NSLock</code>不同的是当进入锁中的线程处于 <code>wait</code>状态时其他线程是可以进入锁中的。<code>creatImage</code>会发出<code>signal</code>信号。随机唤醒一个线程进行图片加载和UI更新。效果如下：</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/gcdgif11.gif" alt="loadImageWithControl"></p>
<h3 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h3><p>本片博客就是以上内容，详细代码在<a href="https://github.com/jiliangzhai/RUSTGCDDemo" target="_blank" rel="external">DEMO</a>中，有兴趣的同学可以下载看一下，最后推荐两个博客。本篇中的一些内容也是参考这两篇博客。</p>
<p><a href="http://www.cnblogs.com/kenshincui/p/3983982.html#GCD" target="_blank" rel="external">iOS开发系列–并行开发其实很容易</a></p>
<p><a href="http://tutuge.me/2015/04/03/something-about-gcd/" target="_blank" rel="external">GCD使用经验与技巧浅谈</a></p>
]]></content>
    <summary type="html">
    <![CDATA[用户在使用程序时期望最小的等待时间，多线程技术有利于充分发挥处理器性能，提高运行效率并能解决线程阻塞的问题。常用的多线程开发有三种方式：NSTread NSOperation GCD。在这篇博客中我们学习的是GCD,这也是目前比较推荐的方式。]]>
    
    </summary>
    
      <category term="ios GCD" scheme="http://rustblogs.com/tags/ios-GCD/"/>
    
      <category term="ios开发" scheme="http://rustblogs.com/categories/ios%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <link href="http://rustblogs.com/2015/12/21/friestblog/"/>
    <id>http://rustblogs.com/2015/12/21/friestblog/</id>
    <published>2015-12-21T14:46:40.000Z</published>
    <updated>2015-12-23T11:30:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5229_u7528hexo_u642D_u5EFA_u535A_u5BA2"><a href="#u5229_u7528hexo_u642D_u5EFA_u535A_u5BA2" class="headerlink" title="利用hexo搭建博客"></a>利用hexo搭建博客</h2><p>本博客是利用hexo+github+七牛做图床搭建的，并绑定了个人域名至guthub，使用的主题名是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">next</a>。</p>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>安装hexo,需要Node,安装Node后在终端输入命令：</p>
<p><code>npm install -g hexo</code></p>
<p><code>hexo init</code></p>
<p>即可安装。</p>
<p>hexo常用命令：</p>
<p><code>hexo new &quot;postName&quot;</code> //新建文章</p>
<p><code>hexo server</code> // 启用本地服务</p>
<p><code>hexo clean</code> //清除缓存</p>
<p><code>hexo g</code> //生成静态网页</p>
<p><code>hexo d</code> //开始部署</p>
<p>博客内容使用Markdown进行编写，推荐MOU编辑器。</p>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>github账号很多人都会有，需要做的就是建立一个名为userName.github.io的仓库，然后在你的博客根目录的_config.yml中进行配置就OK啦。</p>
<h3 id="u56FE_u5E8A"><a href="#u56FE_u5E8A" class="headerlink" title="图床"></a>图床</h3><p>我使用的是七牛云储存，大致过程为申请账号，建立空间，同步本地文件至空间，然后就可以使用外链了。<br>同步本地文件至空间使用的是qrsync同步工具，具体教程可以看这篇文章：<a href="http://www.douban.com/note/526859806/" target="_blank" rel="external">如何使用七牛云做为图床</a>。</p>
<h3 id="u4E3B_u9898"><a href="#u4E3B_u9898" class="headerlink" title="主题"></a>主题</h3><p>本博客使用的是 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">next</a>，比较简洁，作者写的配置信息很详细，有兴趣的同学可以看一下。</p>
<h3 id="u7B2C_u4E00_u7BC7_u535A_u5BA2_u7684_u7ED3_u675F_u8BED"><a href="#u7B2C_u4E00_u7BC7_u535A_u5BA2_u7684_u7ED3_u675F_u8BED" class="headerlink" title="第一篇博客的结束语"></a>第一篇博客的结束语</h3><p>博客搭建的过程大概就是这些了，本人IOS开发菜鸟目前还在机械行业工作，博客以后的内容主要会以IOS开发为主，还会有学习相关知识的内容。希望自己加油。</p>
<p><img src="http://7xpcyy.com1.z0.glb.clouddn.com/boy.jpg" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[开博第一篇博客，理所当然的要总结一下博客的搭建过程，利用hexo搭建个人博客在网上有很多详细的教程，在这里就不多赘述，仅大致描述一下。]]>
    
    </summary>
    
      <category term="hexo blog" scheme="http://rustblogs.com/tags/hexo-blog/"/>
    
      <category term="杂" scheme="http://rustblogs.com/categories/%E6%9D%82/"/>
    
  </entry>
  
</feed>
